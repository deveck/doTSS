// 
// 
//  Author: Andreas Reiter <andreas.reiter@student.tugraz.at>
//  Author: Georg Neubauer <georg.neubauer@student.tugraz.at>

using System;
using Iaik.Tc.TPM.Library.Common;
using Iaik.Tc.TPM.Subsystems.TPMSubsystem;
using Iaik.Utils.Hash;
using System.Security.Cryptography;
using Org.BouncyCastle.Crypto;
using Iaik.Tc.TPM.Library.Common.KeyData;
using Iaik.Tc.TPM.Library.Common.Handles.Authorization;
using Iaik.Tc.TPM.Library.Common.PCRData;
using System.IO;
using Iaik.Tc.TPM.Library.Common.Storage;
using Iaik.Utils;

namespace Iaik.Tc.TPM.Context
{

	/// <summary>
	/// Performs operations with tp keys
	/// </summary>
	public class TPMKeyClient
	{
		/// <summary>
		/// Transmits the packets to the server
		/// </summary>
		private TPMSession _tpmSession;

		public TPMKeyClient (TPMSession tpmSession)
		{
			_tpmSession = tpmSession;
		}		
		
		
		/// <summary>
		/// Gets the Key handle by friendly Name
		/// </summary>
		/// <param name="friendlyName"></param>
		/// <returns></returns>
		public ClientKeyHandle GetKeyHandleByFriendlyName(string friendlyName)
		{
			string identifier = _tpmSession.Keystore.FriendlyNameToIdentifier(friendlyName);
			
			if(friendlyName == null || identifier == null)
				return null;
			
			return new ClientKeyHandle(friendlyName, identifier, _tpmSession);
		}
		
		/// <summary>
		/// Gets the key handle by global identifier
		/// </summary>
		/// <param name="identifier"></param>
		/// <returns></returns>
		public ClientKeyHandle GetKeyHandleByIdentifier(string identifier)
		{
			string friendlyName = _tpmSession.Keystore.IdentifierToFriendlyName(identifier);
			
			if(friendlyName == null || identifier == null)
				return null;
			
			return new ClientKeyHandle(friendlyName, identifier, _tpmSession);
		}
		
		
		/// <summary>
		/// Returns the SRK key handle, it is not checked at this point if the
		/// authorized user is allowed to use the SRK
		/// </summary>
		/// <returns>
		/// A <see cref="ClientKeyHandle"/>
		/// </returns>
		public ClientKeyHandle GetSrkKeyHandle()
		{
			return new ClientKeyHandle("srk", "srk", _tpmSession);
		}
		
		
	}
	
	public class ClientKeyHandle
	{
		/// <summary>
		/// The session this key handle belongs to
		/// </summary>
		private TPMSession _tpmSession;
		
	    /// <summary>
		/// Unique identifier of the TPM key
		/// </summary>
		private string _keyIdentifier;
		
		/// <summary>
		/// Gets the unique key identifier, generated by the server
		/// (hash of the generated TPM_KEY structure)
		/// </summary>
		public string KeyIdentifier
		{
			get{ return _keyIdentifier; }
		}
		
		private string _friendlyName;
		
		/// <summary>
		/// Gets the friendly name of the key
		/// </summary>
		/// <remarks>
		/// The friendly name of a key is also a unique name, but only in the scope 
		/// of the used key storage. 
		///</remarks>
		public string FriendlyName
		{
			get{ return _friendlyName; }
		}
		
		/// <summary>
		/// Retrieves all available informations about this key
		/// </summary>
		public TPMKey KeyInfo
		{
			get
			{
				KeyInfoRequest request = new KeyInfoRequest(_tpmSession.EndpointCtx);
				request.TPMIdentifier = _tpmSession.SessionIdentifier;
				request.KeyIdentifier = _keyIdentifier;
				
				KeyInfoResponse response = request.TypedExecute();
				response.AssertResponse();
				return response.TPMKey;
			}
		}
		
		public TPMPubkey PublicKey
		{
			get
			{
				Parameters paramsGetPubKey = new Parameters ();
				paramsGetPubKey.AddPrimitiveType("key", _keyIdentifier);
				
				TPMCommandResponse response = BuildDoVerifyRequest (TPMCommandNames.TPM_CMD_GetPubKey, paramsGetPubKey);
				
				return response.Parameters.GetValueOf<TPMPubkey> ("pubkey");
			}
		}
		
		public ClientKeyHandle(string friendlyName, string identifier, TPMSession tpmSession)
		{
			_friendlyName = friendlyName;
			_keyIdentifier = identifier;
			_tpmSession = tpmSession;
		}
		
		/// <summary>
		/// Creates a new key with the specified parameters and adds it to the key storage
		/// </summary>
		/// <param name="friendlyName">Unique name in the current keystore</param>
		/// <param name="keyUsage">Specifies the keyUsage of the new key</param>
		/// <param name="keyFlags">Some additional flags</param>
		/// <returns>Returns the newly created key</returns>
		public ClientKeyHandle CreateKey(string friendlyName, TPMKeyUsage keyUsage)
		{
			return CreateKey(friendlyName, keyUsage, TPMKeyFlags.None);
		}
		
		public ClientKeyHandle CreateKey(string friendlyName, TPMKeyUsage keyUsage, TPMKeyFlags keyFlags)
		{
			return CreateKey(friendlyName, 2048, keyUsage, keyFlags);
		}
		
		public ClientKeyHandle CreateKey(string friendlyName, uint keyLength, TPMKeyUsage keyUsage)
		{
			return CreateKey(friendlyName, keyLength, keyUsage, TPMKeyFlags.None);
		}
		
		public ClientKeyHandle CreateKey(string friendlyName, uint keyLength, TPMKeyUsage keyUsage, TPMKeyFlags keyFlags)
		{
			Parameters paramsCreateWrapKey = new Parameters();
			paramsCreateWrapKey.AddPrimitiveType("parent", KeyIdentifier);
			paramsCreateWrapKey.AddPrimitiveType("key_usage", keyUsage);
			paramsCreateWrapKey.AddPrimitiveType("key_flags", keyFlags);
			paramsCreateWrapKey.AddPrimitiveType("key_length", keyLength);
			paramsCreateWrapKey.AddPrimitiveType("exponent", new byte[0]);
			paramsCreateWrapKey.AddPrimitiveType("num_primes", (uint)0);

            if (keyUsage == TPMKeyUsage.TPM_KEY_SIGNING)
            {
                paramsCreateWrapKey.AddPrimitiveType("enc_scheme", TPMEncScheme.TPM_ES_NONE);
                paramsCreateWrapKey.AddPrimitiveType("sig_scheme", TPMSigScheme.TPM_SS_RSASSAPKCS1v15_SHA1);
            }
            else
            {
                paramsCreateWrapKey.AddPrimitiveType("enc_scheme", TPMEncScheme.TPM_ES_RSAESOAEP_SHA1_MGF1);
                paramsCreateWrapKey.AddPrimitiveType("sig_scheme", TPMSigScheme.TPM_SS_NONE);
            }
			
			Parameters parameters = new Parameters();
			parameters.AddPrimitiveType("identifierIsFriendlyName", true);
			parameters.AddPrimitiveType("identifier", friendlyName);
			
			ProtectedPasswordStorage authUsage = _tpmSession.RequestSecret(
				new HMACKeyInfo(HMACKeyInfo.HMACKeyType.KeyUsageSecret, parameters));
			
			if(authUsage.Hashed == false)
				authUsage.Hash();
				
			authUsage.DecryptHash();
			paramsCreateWrapKey.AddPrimitiveType("usage_auth", authUsage.HashValue);
			
			ProtectedPasswordStorage authMigration = null;				
			
			if((keyFlags & TPMKeyFlags.Migratable) == TPMKeyFlags.Migratable)
			{
				authMigration = _tpmSession.RequestSecret(
					new HMACKeyInfo(HMACKeyInfo.HMACKeyType.KeyMigrationSecret, parameters));
				authMigration.DecryptHash();
				paramsCreateWrapKey.AddPrimitiveType("migration_auth", authMigration.HashValue);
			}	
			else
				paramsCreateWrapKey.AddPrimitiveType("migration_auth", new byte[20]);
			
			try
			{
				TPMCommandResponse responseCreateWrapKey = 
					BuildDoVerifyRequest(TPMCommandNames.TPM_CMD_CreateWrapKey, paramsCreateWrapKey);
				
				_tpmSession.Keystore.AddKey(
				            friendlyName,
				            responseCreateWrapKey.Parameters.GetValueOf<string>("key_identifier"),
				            this.FriendlyName,
				            responseCreateWrapKey.Parameters.GetValueOf<byte[]>("key_data"));
				                            
				return new ClientKeyHandle(friendlyName, responseCreateWrapKey.Parameters.GetValueOf<string>("key_identifier"), _tpmSession);
			}
			finally
			{
				if(authMigration != null)
					authMigration.ClearHash();
					
				if(authUsage != null)
					authUsage.ClearHash();
			}
		}
		
		
		/// <summary>
		/// Creates an IAsymmetricBlockCipher for sealing for this key. This is only valid for storage keys
		/// </summary>
		/// <param name="pcrSelection"> </param>
		/// <returns></returns>
		public IAsymmetricBlockCipher CreateSealBlockCipher(TPMPCRSelection pcrSelection)
		{
			return new SealBlockCipher(this, _tpmSession, pcrSelection);
		}
		
		/// <summary>
		/// Creates an IAsymmetricBlockCipher for sealing for this key. This is only valid for storage keys
		/// </summary>
		/// <param name="pcrSelection"> </param>
		/// <returns></returns>
		public IAsymmetricBlockCipher CreateSealBlockCipher(TPMPCRSelection pcrSelection, ProtectedPasswordStorage sealAuth)
		{
			return new SealBlockCipher(this, _tpmSession, pcrSelection, sealAuth);
		}
		
		/// <summary>
		/// Creates a block cipher for binding and unbinding
		/// </summary>
		/// <returns>
		/// </returns>
		public IAsymmetricBlockCipher CreateBindBlockCipher()
		{
			return new BindBlockCipher(this, _tpmSession);
		}
		
		/// <summary>
		/// Reads an encrypted block from the stream.
		/// <see cref="SealBlockCipher"/> for details
		/// </summary>
		/// <param name="encryptedStream"></param>
		/// <returns></returns>
		public byte[] ReadEncryptedBlock(Stream encryptedStream)
		{
			TPMStoredData block = new TPMStoredData(encryptedStream);
			return ByteHelper.SerializeToBytes(block);
		}
		
		/// <summary>
		/// Seals data to the specified pcr selection,
		/// create a valid pcr selection with session.CreateEmptyPCRSelection
		/// </summary>
		/// <param name="pcrSelection"></param>
		/// <param name="data">Data to seal</param>
		/// <returns></returns>
		public byte[] Seal(TPMPCRSelection pcrSelection, byte[] data)
		{
			Parameters paramsSeal = new Parameters();
			paramsSeal.AddPrimitiveType("in_data", data);
			paramsSeal.AddPrimitiveType("key", _keyIdentifier);
			paramsSeal.AddValue("pcr_selection", pcrSelection);
			
			Parameters paramsSecret = new Parameters();
			paramsSecret.AddPrimitiveType("identifier", KeyIdentifier);
			ProtectedPasswordStorage authSeal = _tpmSession.RequestSecret(new HMACKeyInfo(HMACKeyInfo.HMACKeyType.SealAuth, paramsSecret));
			
			if(authSeal.Hashed == false)
				authSeal.Hash();
				
			authSeal.DecryptHash();
			paramsSeal.AddPrimitiveType("data_auth", authSeal.HashValue);
			
			try
			{			
				TPMCommandResponse sealResponse = BuildDoVerifyRequest(TPMCommandNames.TPM_CMD_Seal, paramsSeal);
				return sealResponse.Parameters.GetValueOf<byte[]>("data");
			}
			finally
			{
				if(authSeal != null)
					authSeal.ClearHash();
			}
		}
		
		/// <summary>
		/// Unseals the specified data
		/// </summary>
		/// <param name="data">Data to seal</param>
		/// <returns></returns>
		public byte[] Unseal(byte[] data)
		{
			Parameters paramsSeal = new Parameters();
			paramsSeal.AddPrimitiveType("in_data", data);
			paramsSeal.AddPrimitiveType("key", _keyIdentifier);
			
			Parameters paramsSecret = new Parameters();
			paramsSecret.AddPrimitiveType("identifier", KeyIdentifier);

			
			TPMCommandResponse unsealResponse = BuildDoVerifyRequest(TPMCommandNames.TPM_CMD_Unseal, paramsSeal);
			return unsealResponse.Parameters.GetValueOf<byte[]>("data");
			
		}
		
		/// <summary>
		/// Unbinds the specified data, the encrypted data needs to be
		/// of type TPMBoundData
		/// </summary>
		/// <param name="data"></param>
		/// <returns>Returns the decrypted data</returns>
		public byte[] Unbind(byte[] data)
		{
			Parameters paramsUnbind = new Parameters();
			paramsUnbind.AddPrimitiveType("in_data", data);
			paramsUnbind.AddPrimitiveType("key", _keyIdentifier);
						
			TPMCommandResponse unbindResponse = BuildDoVerifyRequest(TPMCommandNames.TPM_CMD_Unbind, paramsUnbind);
			return unbindResponse.Parameters.GetValueOf<byte[]>("data");
		}

        /// <summary>
        /// Cryptographically reports the selected PCR values
        /// </summary>
        /// <param name="keyName"></param>
        /// <param name="pcrs"></param>
        /// <returns></returns>
        public TPMPCRComposite Quote(TPMPCRSelection pcrs)
        {
            Parameters quoteParameters = new Parameters();
            quoteParameters.AddPrimitiveType("key", _keyIdentifier);
            quoteParameters.AddValue("targetPCR", pcrs);

            return BuildDoVerifyRequest(TPMCommandNames.TPM_CMD_Quote, quoteParameters).Parameters.GetValueOf<TPMPCRComposite>("pcrData");
        }
		
		private TPMCommandResponse BuildDoVerifyRequest (string commandIdentifier, Parameters parameters)
		{
			TPMCommandRequest versionRequest = new TPMCommandRequest (commandIdentifier, parameters);
			TPMCommandResponse response = _tpmSession.DoTPMCommandRequest (versionRequest);
			
			if (response.Status == false)
				throw new TPMRequestException ("An unknown tpm error occured");
			
			return response;
		}
	}
}
